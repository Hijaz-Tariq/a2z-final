this must be a route somewhere 
import { NextResponse } from 'next/server';
import { auth } from '@/auth';
import { db } from '@/lib/db';
import type { Prisma } from '@prisma/client';

export async function POST(req: Request) {
  try {
    const session = await auth();
    const { 
      email,
      shippingAddress = {},
      shippingCost = 0,
      brokerId,
      guestId 
    } = await req.json();

    // Validate required fields
    if (!email) {
      return NextResponse.json(
        { error: 'Email is required' }, 
        { status: 400 }
      );
    }

    // Parse cookies manually for guest sessions
    const cookieHeader = req.headers.get('cookie') || '';
    const guestSessionId = cookieHeader
      .split(';')
      .find(c => c.trim().startsWith('guest_session_id='))
      ?.split('=')[1];

    // Get cart with proper typing
    const cart = await db.cart.findFirst({
      where: {
        OR: [
          { userId: session?.user?.id },
          { guestSessionId },
          { guestId }
        ].filter(Boolean) as Prisma.CartWhereInput[]
      },
      include: { 
        items: {
          include: { product: true }
        }
      }
    });

    if (!cart || cart.items.length === 0) {
      return NextResponse.json(
        { error: 'Cart is empty' },
        { status: 400 }
      );
    }

    // Calculate totals with proper typing
    const subtotal = cart.items.reduce((sum, item) => {
      const price = item.discountPrice ?? item.originalPrice;
      return sum + (Number(price) * item.quantity);
    }, 0);

    const total = subtotal + shippingCost;

    // Prepare order data with all required fields
    const orderData: Prisma.OrderCreateInput = {
      status: 'PENDING',
      total,
      shippingCost,
      shippingAddress,
      ...(session?.user?.id && {
        user: { connect: { id: session.user.id } }
      }),
      ...(guestId && {
        guest: { connect: { id: guestId } }
      }),
      ...(guestSessionId && {
        guestSession: { connect: { id: guestSessionId } }
      }),
      ...(brokerId && {
        broker: { connect: { id: brokerId } }
      }),
      items: {
        create: cart.items.map(item => ({
          product: { connect: { id: item.productId } },
          quantity: item.quantity,
          originalPrice: item.originalPrice,
          discountPrice: item.discountPrice
        }))
      }
    };

    // Transaction with proper error handling
    const order = await db.$transaction(async (tx) => {
      const order = await tx.order.create({
        data: orderData,
        include: { items: true }
      });

      await tx.cartItem.deleteMany({
        where: { cartId: cart.id }
      });

      return order;
    });

    return NextResponse.json({ 
      order,
      success: true 
    }, { status: 201 });

  } catch (error) {
    console.error('Checkout error:', error);
    return NextResponse.json(
      { error: 'Failed to process checkout' },
      { status: 500 }
    );
  }
}



222222222222222222222222222222222222222222222222222222222222222222


import { NextResponse } from "next/server";
import db from "@/lib/prisma";
import { Prisma } from "@prisma/client";

export async function POST(req: Request) {
  const { productId, quantity, sessionId } = await req.json();

  if (!sessionId) {
    return NextResponse.json({ error: "Session ID required" }, { status: 400 });
  }

  try {
    // Verify session exists
    const session = await db.guestSession.findUnique({
      where: { id: sessionId },
    });

    if (!session) {
      return NextResponse.json({ error: "Invalid session" }, { status: 404 });
    }

    // Find or create cart
    let cart = await db.cart.findUnique({
      where: { guestSessionId: sessionId },
    });

    if (!cart) {
      cart = await db.cart.create({
        data: { guestSessionId: sessionId },
      });
    }

    // Check if product exists
    const product = await db.product.findUnique({
      where: { id: productId },
    });

    if (!product) {
      return NextResponse.json({ error: "Product not found" }, { status: 404 });
    }

    // Add or update cart item
    const existingItem = await db.cartItem.findFirst({
      where: {
        cartId: cart.id,
        productId,
      },
    });

    if (existingItem) {
      await db.cartItem.update({
        where: { id: existingItem.id },
        data: { quantity: existingItem.quantity + quantity },
      });
    } else {
      await db.cartItem.create({
        data: {
          cartId: cart.id,
          productId,
          quantity,
          originalPrice: product.price
        } as Prisma.CartItemUncheckedCreateInput
      });
    }

    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      console.log(error, "Failed to add to guest cart"),
      { status: 500 }
    );
    console.error("Detailed error:", {
      error,
      sessionId,
      productId,
      quantity,
      timestamp: new Date().toISOString(),
    });
  }
}



33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333

import { NextResponse } from "next/server";
import { auth } from "@/auth";
import db from "@/lib/prisma";

export async function POST(req: Request) {
  try {
    const session = await auth();
    const { productId, quantity = 1 } = await req.json();

    // Validate input
    if (!productId || typeof quantity !== "number" || quantity < 1) {
      return NextResponse.json(
        { error: "Invalid product ID or quantity" },
        { status: 400 }
      );
    }

    // Get guest session ID
    const cookies = req.headers.get("cookie") || "";
    const guestSessionId = cookies
      .split("; ")
      .find(row => row.startsWith("guest_session_id="))
      ?.split("=")[1];

    // Validate authentication
    if (!session?.user?.id && !guestSessionId) {
      return NextResponse.json(
        { error: "Authentication required" },
        { status: 401 }
      );
    }

    // Handle guest session creation if needed
    if (guestSessionId && !session?.user?.id) {
      await db.guestSession.upsert({
        where: { id: guestSessionId },
        create: { 
          id: guestSessionId,
          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days from now
        },
        update: {},
      });
    }

    // Find or create cart
    let cart = await db.cart.findFirst({
      where: {
        OR: [
          ...(session?.user?.id ? [{ userId: session.user.id }] : []),
          ...(guestSessionId ? [{ guestSessionId }] : [])
        ],
      },
    });

    if (!cart) {
      cart = await db.cart.create({
        data: {
          ...(session?.user?.id && { userId: session.user.id }),
          ...(guestSessionId && { guestSessionId }),
        },
      });
    }

    // Verify product exists
    const product = await db.product.findUnique({
      where: { id: productId },
    });

    if (!product) {
      return NextResponse.json(
        { error: "Product not found" },
        { status: 404 }
      );
    }

    // Update or create cart item
    const existingItem = await db.cartItem.findFirst({
      where: { cartId: cart.id, productId },
    });

    if (existingItem) {
      await db.cartItem.update({
        where: { id: existingItem.id },
        data: {
          quantity: existingItem.quantity + quantity,
          originalPrice: product.price,
          discountPrice: product.discountPrice,
        },
      });
    } else {
      await db.cartItem.create({
        data: {
          cartId: cart.id,
          productId,
          quantity,
          originalPrice: product.price,
          discountPrice: product.discountPrice,
        },
      });
    }

    // Return updated cart
    const updatedCart = await db.cart.findUnique({
      where: { id: cart.id },
      include: { items: { include: { product: true } } },
    });

    return NextResponse.json(updatedCart);

  } catch (error: any) {
    console.error("CART ERROR:", error);
    return NextResponse.json(
      { error: "Failed to update cart", details: error.message },
      { status: 500 }
    );
  }
}

44444444444444444444444444444444444444444444444444444444444444444444444444

